// Code generated by go-libs/v2/dbutils/ops/gen/cmd. DO NOT EDIT.

package tst

import (
	"github.com/top-solution/go-libs/v2/dbutils/ops"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/top-solution/go-libs/v2/dbutils/ops/bobops"
	
	"fmt"
)

// TestStructColumnsMap is a FilterMap mapping filter names to DB columns
// DO NOT EDIT: This var is generated by go-libs/v2/dbutils/ops/gen/cmd
var TestStructColumnsMap = bobops.NewBobFilterMap(map[string]string{
	"test": "stuff","test2": fmt.Sprintf("heee"),"test3": "EEEI","test4": "group_col","test5": "having_ptr_col","test6": "having_array_col","test7": "(CASE WHEN bom.pn = bom.enditem THEN 1 END)","test8": "COALESCE(users.name, users.email, 'Unknown')","test9": "COUNT(*) FILTER (WHERE status = 'active')","test10": "DATE_TRUNC('day', created_at)","test11": simple_column,"test12": tablename.column_name,
})
// AddFilters adds database filters based on the struct fields with db:filter comments
// DO NOT EDIT: This func is generated by go-libs/v2/dbutils/ops/gen/cmd
func (t *TestStruct) AddFilters(q *[]bob.Mod[*dialect.SelectQuery]) error {
	var qmods []bob.Mod[*dialect.SelectQuery]
	
	if t.Test != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "stuff", op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	
	if t.Test2 != nil && *t.Test2 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(*t.Test2)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, fmt.Sprintf("heee"), op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	
	if len(t.Test3) > 0 {
	    for _, v := range t.Test3 {
			op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(v)
			if err != nil {
				return err
			}

			qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "EEEI", op, rawValue, false)
			if err != nil {
				return err
			}
			qmods = append(qmods, qmod)
		}
	}
	
	if t.Test4 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test4)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "group_col", op, rawValue, true)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	
	if t.Test5 != nil && *t.Test5 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(*t.Test5)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "having_ptr_col", op, rawValue, true)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	
	if len(t.Test6) > 0 {
	    for _, v := range t.Test6 {
			op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(v)
			if err != nil {
				return err
			}

			qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "having_array_col", op, rawValue, true)
			if err != nil {
				return err
			}
			qmods = append(qmods, qmod)
		}
	}
	
	if t.Test7 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test7)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "(CASE WHEN bom.pn = bom.enditem THEN 1 END)", op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	if t.Test8 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test8)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "COALESCE(users.name, users.email, 'Unknown')", op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	if t.Test9 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test9)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "COUNT(*) FILTER (WHERE status = 'active')", op, rawValue, true)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	if t.Test10 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test10)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, "DATE_TRUNC('day', created_at)", op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	if t.Test11 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test11)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, simple_column, op, rawValue, false)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	if t.Test12 != "" {
		op, cond, rawValue, err := ops.CurrentWhereFilters().Parse(t.Test12)
		if err != nil {
			return err
		}

		qmod, _, _, err := TestStructColumnsMap.Filterer.ParseFilter(cond, tablename.column_name, op, rawValue, true)
		if err != nil {
			return err
		}
		qmods = append(qmods, qmod)
	}
	

	*q = append(*q, qmods...)

	return nil
}

// AddSorting adds the result of ParseSorting to a given query
func (t *TestStruct) AddSorting(query *[]bob.Mod[*dialect.SelectQuery]) error {
	return TestStructColumnsMap.AddSorting(query, t.Sort)
}


